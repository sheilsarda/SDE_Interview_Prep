# 2967. Minimum Cost to Make Array Equalindromic

You are given a 0-indexed integer array nums having length n.

You are allowed to perform a special move any number of times (including zero) on nums. In one special move you perform the following steps in order:

Choose an index i in the range [0, n - 1], and a positive integer x.
Add |nums[i] - x| to the total cost.
Change the value of nums[i] to x.
A palindromic number is a positive integer that remains the same when its digits are reversed. For example, 121, 2552 and 65756 are palindromic numbers whereas 24, 46, 235 are not palindromic numbers.

An array is considered equalindromic if all the elements in the array are equal to an integer y, where y is a palindromic number less than 109.

Return an integer denoting the minimum possible total cost to make nums equalindromic by performing any number of special moves.

### Failed cpp solution because it didn't generate palindromes correctly

```cpp
#include <limits.h>
#include <algorithm>
#include <string>
#include <iostream>
#include <unordered_set>

class Solution {
private:
    long reverseNumber(long n){
        auto longToString = std::to_string(n);
        std::reverse(longToString.begin(), longToString.end());
        return std::stol(longToString);
    }
public:
    long long minimumCost(vector<int>& nums) {
        // maintain min cost (set to max_int)
        // sort nums
        // iterate through all numbers in the range of nums
        //  compute cost; as soons as cost > min, then exit
        //  return number with the min cost

        std::sort(nums.begin(), nums.end());
        std::cout << "num elements in array " << nums.size() << " min " << nums[0] << " max " << nums[nums.size() - 1] << std::endl;
        

        std::unordered_set<long> palindromes_to_consider;

        for(int i = nums[0]; i <= nums[nums.size() - 1]; ++i){
            if (reverseNumber(i) == i){
                palindromes_to_consider.insert(i);
                std::cout << "found palindromic string in array of " << i << std::endl;
                continue;
            }
        
            auto longToString = std::to_string(i);
            for(int j = std::ceil(longToString.size() / 2); j < longToString.size(); ++j){
                longToString[j] = longToString[longToString.size() - 1 - j];
            }
            palindromes_to_consider.insert(std::stol(longToString));
            std::cout << "made palindromic string from " << i << " -> " << longToString << std::endl;
        }

        long min_cost = LONG_MAX;
        // auto cost_map = std::unordered_map<int, int>();
        for(long palindromic_number : palindromes_to_consider){
            std::cout << "considering palindromic number " << palindromic_number << std::endl;
                        // compute cost
            long running_cost = 0;
            for(long array_element : nums){
                running_cost += std::abs(array_element - palindromic_number);
                // if(running_cost > min_cost){
                //     running_cost = LONG_MAX;
                //     break;
                // }
            }
            min_cost = std::min(running_cost, min_cost);
            // cost_map[palindromic_number] = running_cost;
        }

        return min_cost;
    }
};
```

### Correct solution

```cpp
class Solution {
public:
    bool isPalindrome(int n){
        string s=to_string(n);
        int i=0,j=s.size()-1;
        while(i<=j){
            if(s[i++]!=s[j--])return false;
        }
        return true;
    }
    int dec(int x){
        while(!isPalindrome(x)){
            x++;
        }
        return x;
    }
    int inc(int x){
        while(!isPalindrome(x)){
            x--;
        }
        return x;
    }
    long long val(int a,vector<int> nums){
        long long ans=0;
        for(int i:nums){
            ans+=abs(i-a);
        }
        return ans;
    }
    long long minimumCost(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());

        int a = inc(nums[n / 2]), b = dec(nums[n / 2]);

        return min(val(a, nums), val(b, nums));
    }
};
```