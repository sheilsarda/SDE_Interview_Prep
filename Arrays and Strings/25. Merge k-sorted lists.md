# Merge k Sorted Lists

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.

## Constraints:

- k == lists.length
- 0 <= k <= 104
- 0 <= lists[i].length <= 500
- -104 <= lists[i][j] <= 104
- lists[i] is sorted in ascending order
- The sum of lists[i].length will not exceed 104

## Examples

````sh
Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:
Input: lists = []
Output: []

Example 3:
Input: lists = [[]]
Output: []
````

## C++ Solution

### Solution 1: Ordered map

````cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // map key is value in the linked list, value is frequency it appears
        map<int, int> valCounter;
        for(auto& listPointer: lists){
            while(listPointer){
                valCounter[listPointer->val]++;
                listPointer = listPointer->next;
            }
        }
        // none or empty linked lists provided
        if(!valCounter.size()) return nullptr; 
        
        std::shared_ptr<ListNode> mergedList(new ListNode());
        ListNode* listElem = mergedList.get();
        for(auto& mapElem: valCounter){
            // for loop runs [frequency of elem] times (value of map)
            for(int i = 0; i < mapElem.second; i++){
                // insert [key] from valCounter map [value] # of times
                listElem->next = new ListNode(mapElem.first);
                listElem = listElem->next;
            }
        }
        return mergedList->next;
    }
};
````

### Solution 2: in-place swap

````cpp
class Solution {
public:
    // O(nlogk) - time complexity
    // O(1) - memory complexity

    ListNode* mergeKLists(std::vector<ListNode*>& lists) {
        int n = static_cast<int>(lists.size());
        if (!n || n == 1 && lists.front() == nullptr) return nullptr;
        ListNode* last = nullptr;
        while(n > 1) {
            int cnt = 0;
            for(int i = 0; i < n - 1; i+=2) {
                lists[i] = merge2Lists(lists[i], lists[i + 1]);
                swap(lists[i], lists[cnt]);
                ++cnt;
            }
            swap(lists[n-1], lists[cnt]);
            n = n/2 + n%2;
        }
        return lists.front();
    }

    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {
        start = nullptr;
        if (l1 && l2) {
            if (l1->val < l2->val) {
                start = l1;
                l1 = l1->next;
            } else {
                start = l2;
                l2 = l2->next;
            }
        } else if (l1) { return l1; }
        else if (l2) { return l2; }
        else return nullptr;
        ListNode* cur = start;
        while(true) {
            if (l1 && l2) {
                if (l1->val < l2->val) {
                    cur->next = l1;
                    cur = cur->next;
                    l1 = l1->next;
                } else {
                    cur->next = l2;
                    cur = cur->next;
                    l2 = l2->next;
                }
            } else if (l1) {
                cur->next = l1;
                break;
            } else if (l2) {
                cur->next = l2;
                break;
            } else break;
        }
        return start;
    }
    ListNode* start = nullptr;
};
````