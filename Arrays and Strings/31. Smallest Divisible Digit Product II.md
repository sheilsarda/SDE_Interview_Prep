# 3348. Smallest Divisible Digit Product II

You are given a string num which represents a positive integer, and an integer t.

A number is called zero-free if none of its digits are 0.

Return a string representing the smallest zero-free number greater than or equal to num such that the product of its digits is divisible by t. If no such number exists, return "-1".

````
Example 1:

Input: num = "1234", t = 256

Output: "1488"

Explanation:

The smallest zero-free number that is greater than 1234 and has the product of its digits divisible by 256 is 1488, with the product of its digits equal to 256.

Example 2:

Input: num = "12355", t = 50

Output: "12355"

Explanation:

12355 is already zero-free and has the product of its digits divisible by 50, with the product of its digits equal to 150.

Example 3:

Input: num = "11111", t = 26

Output: "-1"

Explanation:

No number greater than 11111 has the product of its digits divisible by 26.
````
 

### Constraints:

- 2 <= num.length <= 2 * 105
- num consists only of digits in the range ['0', '9'].
- num does not contain leading zeros.
- 1 <= t <= 1014


#### Solution 1. Brute Force (w/ some potential bugs)

````cpp
class Solution {
public:
    string smallestNumber(string num, long long t) {
        auto foundResult = false;
        auto numInt = std::atoi(num.c_str());
        while(!foundResult){
            auto isZeroFree = IsZeroFree(numInt);
            
            if (!isZeroFree){
                numInt++;
                continue;
            }

            auto productOfDigits = ProductOfDigits(numInt);
            if (productOfDigits % t == 0 && productOfDigits > t)
                return std::to_string(numInt);

            numInt++;
        }
        
        return "-1";
    }

    bool IsZeroFree(int num){
        auto num_str = std::to_string(num);
        return num_str.find('0') == string::npos;
    }

    int ProductOfDigits(int num){
        auto num_str = std::to_string(num);
        int running_product = 1;
        for(char digit : num_str){
            running_product *= int(digit);
        }
        return running_product;
    }
};
````

#### Solution 2. Optimal

````cpp
class Solution {
private:
    /// @brief same as std::gcd but notably returns `b` if `a` is 0
    long long gcd(long long a,long long b) {
        if (a == 0) return b;
        return gcd(b % a, a);
    }

    /// @brief same as string::compare with the optimization that if a is longer than b (string length), it must be larger than b in value and vice versa
    bool check(string a, string b) {
        if (a.length() > b.length()) return true;
        if (a.length() < b.length()) return false;
        return a.compare(b) > 0;
    }

public:

    /*
    @brief: The length of the input num is stored in n. A vector remind of size n + 1 is initialized to track the division progress; the first element is set to t. end is initialized to n to track the index where processing stops.

    Determine Valid Prefix:

    Iterate through the digits of num to compute a prefix sequence where the GCD of remind[i] and the current digit (num[i]) divides t progressively. If a digit is 0, stop processing (end = i + 1) because division by 0 is invalid. Store the new remind value for each position.

    Check if Entire num is Valid:

    If the loop completes and remind[n] == 1, return num because it is already valid.

    Backtracking and Modification:

    Iterate backward from end - 1 to attempt modifying digits of num to satisfy the divisibility constraint. For each digit, increment it and recompute remind for the remaining digits. If a valid sequence is found (remind == 1), return the modified num.

    Construct a New Number:

    If modifying num fails, construct a new number entirely from scratch.
    Start with the largest factors of t (from 9 to 2) and greedily include them in the result string (res). Reverse the resulting string to get the smallest number possible.
    
    Handle Edge Cases:

    If t cannot be fully factored (i.e., t != 1), return "-1".
    Use the check function to compare the newly constructed number (res) with num.
    If necessary, prepend additional 1s to res to match or exceed the length of num.

    Return the smallest valid number as the result.
    */
    string smallestNumber(string num, long t) {
        int n = num.length();
        vector<long> remind(n + 1);
        remind[0] = t;
        int end = n;
        for (int i = 0; i < n; i++) {
            if (num[i] == '0') {
                end = i + 1;
                break;
            }
            remind[i + 1] = remind[i] / gcd(remind[i], num[i] - '0');
        }
        if (end == n && remind[n] == 1) return num;

        for (int i = end - 1; i >= 0; i--) {
            while (num[i] < '9') {
                long tt = remind[i];
                num[i]++;
                tt /= gcd(tt, num[i] - '0');
                for (int j = n - 1; j > i; j--) {
                    for (int k = 9; k > 0; k--) {
                        if (tt % k == 0) {
                            tt /= k;
                            num[j] = '0' + k;
                            break;
                        }
                    }
                }
                if (tt == 1) return num;
            }
        }

        string res;
        for (int i = 9; t > 1 && i > 1; i--) {
            while (t % i == 0) {
                res += to_string(i);
                t /= i;
            }
        }
        if (t != 1) return "-1";
        reverse(res.begin(), res.end());
        if (check(res, num)) return res;
        if (res.length() == num.length()) return "1" + res;

        int dif = num.length() - res.length();
        if (check(string(dif, '1') + res, num)) return string(dif, '1') + res;
        return string(dif + 1, '1') + res;
    }
};
````