# Contains duplicate III

Given an integer array `nums` and two integers `k` and `t`, return true if there are two distinct indices `i` and `j` in the array such that `abs(nums[i] - nums[j]) <= t` and `abs(i - j) <= k`.

## Examples

````sh
Input: nums = [1,2,3,1], k = 3, t = 0
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1, t = 2
Output: true
Example 3:

Input: nums = [1,5,9,1,5,9], k = 2, t = 3
Output: false
````

## C++ Solution

## Pseudocode

````sh
[1,5,2,4,3,9,1,5,9], k = 2, t = 3

1 // (3+1) = 0
5 // (3+1) = 1
2 // (3+1) = 0
4 // (3+1) = 1
3 // (3+1) = 0
9 // (3+1) = 2
````

Here, `Bucket[0]` will contain numbers 0,1,2,3.
`Bucket[1]` will contain numbers 4,5,6,7.
`Bucket[2]` will contain numbers 8,9,10,11.

On observing carefully, we can see that the absolute difference
between any two numbers in any bucket is at most t, which is what we want.

Also, there can be a case where the neighboring bucket has some number
whose absolute difference with a number in the current bucket is at most t.
For instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).
This can only happen in neighboring buckets. Therefore, we need to check for this too.


### Code

````cpp
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
    int n = nums.size();
    
    if(n == 0 || k < 0  || t < 0) return false;
    
    unordered_map<int,int> buckets;
    
    for(int i=0; i<n; ++i) {
        int bucket = nums[i] / ((long)t + 1);
        
        // For negative numbers, we need to decrement bucket by 1
        // to ensure floor division.
        // For example, -1/2 = 0 but -1 should be put in Bucket[-1].
        // Therefore, decrement by 1.
        if(nums[i] < 0) --bucket;
        
        if(buckets.find(bucket) != buckets.end()) return true;
        else {
            buckets[bucket] = nums[i];
            if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;
            if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;
            
            if(buckets.size() > k) {
                int key_to_remove = nums[i-k] / ((long)t + 1);
                
                if(nums[i-k] < 0) --key_to_remove;
                
                buckets.erase(key_to_remove);
            }
        }
    }
    
    return false;
}
````
