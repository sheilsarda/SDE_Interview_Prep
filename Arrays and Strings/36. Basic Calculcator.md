# 224. Basic Calculcator

Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.

Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

 

Example 1:

Input: s = "1 + 1"
Output: 2
Example 2:

Input: s = " 2-1 + 2 "
Output: 3
Example 3:

Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
 

Constraints:

1 <= s.length <= 3 * 105
s consists of digits, '+', '-', '(', ')', and ' '.
s represents a valid expression.
'+' is not used as a unary operation (i.e., "+1" and "+(2 + 3)" is invalid).
'-' could be used as a unary operation (i.e., "-1" and "-(2 + 3)" is valid).
There will be no two consecutive operators in the input.
Every number and running calculation will fit in a signed 32-bit integer.

### CPP solution

```cpp
#include <vector>
#include <stack>
#include <string>
#include <algorithm>
using namespace std;
class Solution {
public:

    int calculate(string s) {
        std::string last_num = "";
        std::vector<string> delimited_string;
        std::vector<char> operator_list = {'+', '-', '*', '/', '(', ')'};
        for(int i = 0; i < s.length(); i++) {
            if (std::find(operator_list.begin(), operator_list.end(), s[i]) != operator_list.end()){
                if (last_num.length() > 0)
                    delimited_string.push_back(last_num);
                delimited_string.push_back(std::string(1, s[i]));
                last_num = "";
            } else if (isdigit(s[i])) {
                last_num += s[i];
            }
        }
        delimited_string.push_back(last_num);
        auto num_parentheses = 0;
        std::stack<string> parentheses_stack;
        for(int i = 0; i < delimited_string.size(); i++) {
            if (delimited_string[i] == "(") {
                parentheses_stack.push(delimited_string[i]);
                num_parentheses++;
            } else if (delimited_string[i] == ")") {
                num_parentheses--;
                std::vector<string> problem_within_parentheses = {};
                while(parentheses_stack.top() != "(") {
                    problem_within_parentheses.push_back(parentheses_stack.top());
                    parentheses_stack.pop();
                }
                parentheses_stack.pop();
                std::reverse(problem_within_parentheses.begin(), problem_within_parentheses.end());
                auto result = SolveNoParenthesesMathProblem(problem_within_parentheses);
                parentheses_stack.push(std::to_string(result));
            } else {
                parentheses_stack.push(delimited_string[i]);
            }
        }

        std::vector<string> final_problem = {};
        while(!parentheses_stack.empty()) {
            final_problem.push_back(parentheses_stack.top());
            parentheses_stack.pop();
        }
        std::reverse(final_problem.begin(), final_problem.end());
        return SolveNoParenthesesMathProblem(final_problem);
    }

    int SolveNoParenthesesMathProblem(std::vector<string> problem){
        std::stack<int> math_stack;
        for(int i = 0; i < problem.size(); i++) {
            if (problem[i] == "*") {
                auto int_result = math_stack.top() * stringToInteger(problem[i + 1]);
                math_stack.pop();
                math_stack.push(int_result);
                ++i;
            } else if (problem[i] == "/") {
                auto int_result = math_stack.top() / stringToInteger(problem[i + 1]);
                math_stack.pop();
                math_stack.push(int_result);
                ++i;
            } else if (problem[i] == "+") {
                math_stack.push(stringToInteger(problem[i + 1]));
                ++i;
            } else if (problem[i] == "-") {
                math_stack.push(-1 * stringToInteger(problem[i + 1]));
                ++i;
            } else if (problem[i].length() > 0) {
                math_stack.push(stringToInteger(problem[i]));
            }
        }

        int to_return = 0;
        while(!math_stack.empty()) {
            to_return += math_stack.top();
            math_stack.pop();
        }
        return to_return;
    }

    int stringToInteger(string s) {
        try{
            return stoi(s);
        } catch(const std::invalid_argument& e) {
            std::cout << "s: " << s << std::endl;
            std::cout << "Error: " << e.what() << std::endl;
            return INT_MAX;
        }
    }
};
```

### Faster CPP solution

```cpp
class Solution {
public:
    int calculate(string s) {
        stack<long long> nums, ops;
        long long total = 0, num = 0;
        int sign = 1;

        for(char c : s){
            if(isdigit(c)){
                num = num * 10 + (c - '0');
            }else{
                total += sign * num;
                num = 0;
                if(c == '+')
                    sign = 1;
                else if(c == '-')
                    sign = -1;
                else if(c == '('){
                    nums.push(total);
                    ops.push(sign);
                    total = 0;
                    sign = 1;
                }
                else if(c == ')'  && ops.size()){
                    total = ops.top() * total + nums.top();
                    ops.pop(); nums.pop();
                }
            }
        }

        total += sign * num;
        return (int)total;
    }
};
```