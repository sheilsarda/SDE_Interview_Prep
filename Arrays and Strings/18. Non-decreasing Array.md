# Check if an array with `n` integers can become non-decreasing by modifying at most one element

Given an array `nums` with `n` integers, your task is to check if it could become non-decreasing by modifying at most one element.

We define an array is non-decreasing if `nums[i] <= nums[i + 1]` holds for every `i` (0-based) such that `(0 <= i <= n - 2)`.

## Examples

````sh
Input: nums = [4,2,3]
Output: true
````

Explanation: You could modify the first 4 to 1 to get a non-decreasing array.

````sh
Input: nums = [4,2,1]
Output: false
````

Explanation: You can't get a non-decreasing array by modify at most one element.

## C++ Solution 1

### Code

````cpp
bool checkPossibility(vector<int>& nums) {
    int count = 1;
    int min_value = INT_MIN;
    for(int i = 0; i < nums.size()-1; i++){
        if(nums[i] <= nums[i + 1]){
            min_value = nums[i];
        }else{
            if(nums[i + 1] < min_value){
                nums[i+1] = nums[i];
            }
            count -= 1;
        }
    }
    if(count < 0){
        return false;
    }else{
        return true;
    }
}
````

## C++ Solution 2

### Pseudocode 

````sh
When there is violation, e.g. nums[i-1]>nums[i], The array could be sorted either 
changing nums[i-1] (e.g., nums[i-1]=nums[i]) or
changing nums[i] (nums[i]=nums[i-1]). 

What it will be it could be determined from previous element, nums[i-2], 
if(nums[i-2]<nums[i]), the problem is in nums[i-1].
if(nums[i-2]>nums[i]), the problem is in nums[i]
````
### Code

````cpp
bool checkPossibility(vector<int>& nums) {
    
    int violation=0;
    
    for(int i=1; i<nums.size(); i++){
        if(nums[i-1]>nums[i]){
            violation++;
            if(violation>1) return false;
            
            if(i-2<0 || nums[i-2]<=nums[i]){
                nums[i-1]=nums[i];
            }else{
                nums[i]=nums[i-1];
            }
        }
    }

    return true;
}
````

## Complexity Analysis:

`O(n)` runtime and `O(1)` space