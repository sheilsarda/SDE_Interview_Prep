### 3276. Select Cells In Grid With Maximum Score

You are given a 2D matrix grid consisting of positive integers.

You have to select one or more cells from the matrix such that the following conditions are satisfied:

No two selected cells are in the same row of the matrix.
The values in the set of selected cells are unique.
Your score will be the sum of the values of the selected cells.

Return the maximum score you can achieve.

````cpp
class Solution {
public:
    /*
    @brief The process involves grouping all grid values by their magnitude using a map (mp), associating each value with the set of rows it belongs to. The algorithm then iterates through the values in descending order and updates the dp array by considering all possible states (represented by mask). For each value, it checks whether the current row is already used in the state (via the bitmask) and skips it if so. If the row is unused, the state is updated, and the score for that state is maximized by including the current value. The final result is the maximum score stored in the last state of dp.
    */
    int maxScore(vector<vector<int>>& grid) {
        int numRows = grid.size(); // Number of rows in the grid
        vector<int> dp(1 << numRows, 0); // dp[mask] stores the maximum score for the current state represented by 'mask'
        unordered_map<int, set<int>> valueToRowsMap; // Map each grid value to the rows it belongs to

        // Populate the map with grid values and their corresponding rows
        for (int row = 0; row < numRows; ++row) {
            for (auto& value : grid[row]) {
                valueToRowsMap[value].insert(row);
            }
        }

        // Iterate through the values in the map in descending order of their keys
        for (auto& valueEntry : valueToRowsMap) {
            int value = valueEntry.first; // The grid value
            set<int>& rows = valueEntry.second; // The set of rows where this value appears

            // Traverse all possible states (represented by masks) in reverse order
            for (int mask = (1 << numRows) - 1; mask >= 0; --mask) {
                // Attempt to assign the current value to one of the rows in the current mask state
                for (auto& row : rows) {
                    // Check if the current row is already used in the current state
                    if ((mask >> row) & 1) continue;

                    // Update the state by assigning the current value to this row
                    int newMask = mask ^ (1 << row); // Add the row to the new state
                    dp[newMask] = max(dp[newMask], dp[mask] + value); // Update the dp array
                }
            }
        }

        // Return the maximum score, which is stored in the last state of the dp array
        return dp.back();
    }
};


````