# Substring with Concatenation of All Words

- You are given a string s and an array of strings words. All the strings of words are of the same length.
- A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.
- For example, if words = ["ab","cd","ef"], then "abcdef", "abefcd", "cdabef", "cdefab", "efabcd", and "efcdab" are all concatenated strings. 
- "acdbef" is not a concatenated substring because it is not the concatenation of any permutation of words.
- Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.

## Examples 

````
Example 1:
Input: s = "barfoothefoobarman", words = ["foo","bar"]
Output: [0,9]
Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.
The substring starting at 0 is "barfoo". It is the concatenation of ["bar","foo"] which is a permutation of words.
The substring starting at 9 is "foobar". It is the concatenation of ["foo","bar"] which is a permutation of words.
The output order does not matter. Returning [9,0] is fine too.

Example 2:
Input: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
Output: []
Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.
There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.
We return an empty array.

Example 3:
Input: s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
Output: [6,9,12]
Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.
The substring starting at 6 is "foobarthe". It is the concatenation of ["foo","bar","the"] which is a permutation of words.
The substring starting at 9 is "barthefoo". It is the concatenation of ["bar","the","foo"] which is a permutation of words.
The substring starting at 12 is "thefoobar". It is the concatenation of ["the","foo","bar"] which is a permutation of words.
````

## Code

````cpp
class Solution {

private:
	// function to remove a word from usedWords hasmap
    void remove(unordered_map<string, int> &hashmap, string &key) {
        hashmap[key]--;
        if(hashmap[key] <= 0)
            hashmap.erase(key);
    }
    
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        unordered_map<string, int> wordDict, usedWords;
        int word_len = words[0].length(), total_words = words.size(), words_used = 0;
        int left = 0, right = 0, n = s.length();
        vector<int> ans;
        
		// wordDict contains all words with their frequencies
        for(auto &word: words)
            wordDict[word]++;
        
		// We iterate staring from every index in range [0, word_len] to get every possible combination
        for(int i=0; i<word_len; i++) {
			// right pointer is used to expand the current window and left pointer is used to shrink the current 
            // window whenever the window becomes invalid
            left = i, right = i;
            usedWords.clear();
            words_used = 0;
			
			// Once we pick a word of length 'word_len' then we go to next index = 'right + word_len'
            while(right < n)
            {
                auto curr = s.substr(right, min(n-right, word_len));
                
				// If the curr picked word does not exist in the words array given to us then current window is no 
                // longer useful; discard all words used so far and increment right + left pointer to point to next word
                if(wordDict.find(curr) == wordDict.end())
                {
                    usedWords.clear();
                    words_used = 0;
                    right += word_len;
                    left = right;
                    continue;
                }
                
				// If freq of curr word is less then required freq of that word we can add it to our usedWords and 
                // also increment the no of words that we have used in the current window
                if(usedWords[curr] < wordDict[curr]) 
                    usedWords[curr]++, words_used++;
				
                // If freq is higher then we start removing words from the begining of window until window becomes valid
                else
                {
                    while(left < right)
                    {
                        auto to_remove = s.substr(left, word_len);
                        remove(usedWords, to_remove);
                        words_used--;
                        left += word_len;
                        if(usedWords[curr] < wordDict[curr])
                            break;
                    }
					// Now the window has becomes valid so we can add the curr word to the usedWords
                    usedWords[curr]++, words_used++;
                }
                right += word_len;
				
				// if the words of our current window get equal to the total words required the we can add the index 
                // of the starting of the window(left pointer) to our answer array and move the left pointer one 
                // step forward. We cant set the left pointer to point to right because we might have an answer 
                // starting from 'left+word_len'. So we only increment it one step forward.
                if(words_used == total_words)
                {                    
                    ans.push_back(left);
                    auto to_remove = s.substr(left, word_len);
                    remove(usedWords, to_remove);
                    words_used--;
                    left += word_len;
                }
            
            }
        }
        return ans;
    }
};

````