# 12. Find all overlap between intervals


Write a function, given two time intervals, return the time interval where they overlap. Then extend this to handle two lists of intervals, return all intervals where the two overlap. 

 
 
```
 [[-2, 0], [2, 3], [4, 5]] 

 [[-1, 1], [2, 5]] 

=[[-1, 0], [2, 3], [4, 5]] 
```

### CPP solution

 
```cpp
#include <cstdint> 
#include <iostream> 
#include <optional> 
#include <vector> 
#include <algorithm> 
using namespace std; 

struct Interval { 

  int start, end; 

  Interval (int s, int e) : start(s), end(e) {} 

}; 

std::optional<Interval> findOverlap(Interval a, Interval b){ 

  if (min(a.end, b.end) < max(a.start, b.start)){ 

    return nullopt; 

  } 

  return Interval(max(a.start, b.start), min(a.end, b.end)); 

} 

std::vector<Interval> findOverlapBetweenListOfIntervals(std::vector<Interval> listA, std::vector<Interval> listB){ 

  std::vector<Interval> result; 

  for(auto interval_a : listA){ 

    for(auto interval_b : listB){ 

      auto overlapping_interval = findOverlap(interval_a, interval_b); 

      if(overlapping_interval.has_value()) 

        result.push_back(overlapping_interval.value()); 

    } 

  } 

  return result; 

} 

bool sortByStartTime(Interval intA, Interval intB){ 

  return intA.start <= intB.start; 

} 


std::vector<Interval> findOverlapBetweenListOfIntervalsB(std::vector<Interval> listA, std::vector<Interval> listB){ 
  std::vector<Interval> result; 

  std::sort(listA.begin(), listA.end(), sortByStartTime); 

  std::sort(listB.begin(), listB.end(), sortByStartTime); 

  auto listA_iter = listA.begin(); 

  auto listB_iter = listB.begin(); 

  while(listA_iter != listA.end() && listB_iter != listB.end()){ 
    auto listA_element = (*listA_iter); 
    auto listB_element = (*listB_iter); 

    // if the end of the interval with smaller start time is less than start of the other one, then no overlap and don't add to result 
    // else start overlap at bigger start, and end it at smaller end 
    if (listA_element.start <= listB_element.start){ 

      // A has the smaller start time 

      if (listA_element.end >= listB_element.start){ 

        result.push_back({listB_element.start, min(listA_element.end, listB_element.end)}); 

      } 

      listA_iter++; 

    } else{ 

      // B has the smaller start time 

      if (listB_element.end >= listA_element.start){ 

        result.push_back({listA_element.start, min(listA_element.end, listB_element.end)}); 

      } 
      listB_iter++; 
    } 
  } 

  return result; 

} 

 
 

/* 

  1. Sort the list based on start time 

  2. 2 pointers; 1 for each list, looking at start time  

*/ 

int main() { 

                                              // 

  std::vector<Interval> listA =  {{-2, 0}, {2, 3}, {4, 5}}; 

                                    // 

  std::vector<Interval> listB =  {{-1, 1}, {2, 5}}; 

  auto result = findOverlapBetweenListOfIntervalsB(listA, listB); 

  for(auto overlappingInterval : result){ 

    cout << overlappingInterval.start << ", " << overlappingInterval.end << endl; 

  } 

}
 ```