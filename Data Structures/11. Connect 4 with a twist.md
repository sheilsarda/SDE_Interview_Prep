# Connect-k with insrt from bottom

Design a Connect Four game system with two unique twists:
1. Players insert pieces at the bottom of columns, pushing existing pieces upward
2. The game board has no fixed boundaries - it extends infinitely in both horizontal directions and upward

#### Game Rules

1. The game is played on an infinite grid where:
   * X-axis ranges from [-∞, +∞]
   * Y-axis ranges from [0, +∞] where Y=0 is the bottom
2. Two players take turns placing colored pieces (e.g., Red and Yellow)
3. Bottom Insert Rule: When a player selects column X, their piece is inserted at position (X, 0), and all existing pieces in that column shift up by one position
4. There is no maximum height for any column
5. The first player to connect K pieces in a row (horizontally, vertically, or diagonally) wins
6. The game supports tournament mode with score tracking

#### Design and implement the following:

1. Grid Class: Manages an infinite game board
   * Efficiently store only occupied positions (sparse representation)
   * Insert pieces at (X, 0) with upward shift for all pieces in column X
   * Check win conditions without bounded iteration

```cpp
#include <unordered_map>
#include <vector>
#include <deque>
#include <set>
#include <algorithm>
#include <iostream>

class ConnectFourInfinite {
private:
    // Store grid as column -> vector of pieces (bottom to top)
    std::unordered_map<int, std::deque<int>> columns;

    // Track all occupied positions for win checking
    std::unordered_map<int, std::unordered_map<int, int>> grid; // x -> (y -> player)
    
    int k; // Number of pieces to connect for win
    int currentPlayer;
    int lastX, lastY; // Last move position
    
    struct Score {
        int wins = 0;
        int losses = 0;
        int draws = 0;
    };
    std::unordered_map<int, Score> playerScores;
    
public:
    ConnectFourInfinite(int connectK = 4) : k(connectK), currentPlayer(1) {}
    
    // Insert piece at bottom of column X
    bool makeMove(int x) {
        // Clear old position data for this column
        if (columns.count(x)) {
            for (int y = 0; y < columns[x].size(); y++) {
                grid[x].erase(y);
            }
        }
        
        // Insert at bottom
        columns[x].push_front(currentPlayer);
        
        // Update grid with new positions
        for (int y = 0; y < columns[x].size(); y++) {
            grid[x][y] = columns[x][y];
        }
        
        lastX = x;
        lastY = 0; // Always inserted at bottom
        
        bool won = checkWin(x, 0, currentPlayer);
        
        if (!won) {
            currentPlayer = (currentPlayer == 1) ? 2 : 1;
        }
        
        return won;
    }
    
    // Check if current player won from position (x, y)
    bool checkWin(int x, int y, int player) {
        // Directions: horizontal, vertical, diagonal-right, diagonal-left
        std::vector<std::pair<int, int>> directions = {
            {1, 0}, {0, 1}, {1, 1}, {1, -1}
        };
        
        for (auto& [dx, dy] : directions) {
            int count = 1; // Count the current piece
            
            // Check positive direction
            count += countDirection(x, y, dx, dy, player);
            
            // Check negative direction
            count += countDirection(x, y, -dx, -dy, player);
            
            if (count >= k) {
                return true;
            }
        }
        
        return false;
    }
    
    // Count consecutive pieces in one direction
    int countDirection(int startX, int startY, int dx, int dy, int player) {
        int count = 0;
        int x = startX + dx;
        int y = startY + dy;
        
        while (true) {
            // Check if position exists and belongs to player
            if (grid.count(x) && grid[x].count(y) && grid[x][y] == player) {
                count++;
                x += dx;
                y += dy;
            } else {
                break;
            }
        }
        
        return count;
    }
    
    // Get current board state (for visualization)
    void printBoard(int minX = -5, int maxX = 5, int maxY = 10) {
        std::cout << "Current Board:\n";
        
        for (int y = maxY; y >= 0; y--) {
            for (int x = minX; x <= maxX; x++) {
                if (grid.count(x) && grid[x].count(y)) {
                    std::cout << grid[x][y] << " ";
                } else {
                    std::cout << ". ";
                }
            }
            std::cout << "\n";
        }
        std::cout << "\n";
    }
    
    // Tournament mode functions
    void recordGameResult(int winner, bool isDraw = false) {
        if (isDraw) {
            playerScores[1].draws++;
            playerScores[2].draws++;
        } else {
            int loser = (winner == 1) ? 2 : 1;
            playerScores[winner].wins++;
            playerScores[loser].losses++;
        }
    }
    
    void resetGame() {
        columns.clear();
        grid.clear();
        currentPlayer = 1;
    }
    
    Score getPlayerScore(int player) {
        return playerScores[player];
    }
    
    // Get all occupied positions (for advanced analysis)
    std::vector<std::tuple<int, int, int>> getOccupiedPositions() {
        std::vector<std::tuple<int, int, int>> positions;
        for (auto& [x, col] : grid) {
            for (auto& [y, player] : col) {
                positions.push_back({x, y, player});
            }
        }
        return positions;
    }
};
```

