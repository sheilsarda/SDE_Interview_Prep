# 25. Reverse Nodes in k-Group

Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

## Example:

Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5

## Code: C++

````cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* curr, int k) {
        int t=0;
        ListNode* prev=nullptr, *check=curr;
        while(t<k && check!=nullptr) check=check->next,t++;   //checking if there are k nodes left to be reversed (using loop)
        if(t<k) return curr;  // if there are less than k nodes we need not reverse so return the normal List
        while(t-- && curr!=nullptr){   // reversing loop
            ListNode* next= curr->next;
            curr->next=prev;
            prev=curr;
            curr=next;
        }
        ListNode* tail=prev;  //iterating till tail of the current reversed List
        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;  //  so that we can attach it to  recursively reversed upcomming List
        tail->next = curr ? reverseKGroup(curr,k) : nullptr;  //attacing the next upcomming reverse list the current reversed List
        return prev;
    }
};
````

## Code: Java

````java
public ListNode reverseKGroup(ListNode head, int k) {

		if (k == 0 || k == 1)
			return head;

		int length = len(head);
		ListNode prev = null;
		ListNode lastNodeofFirstPart = null;
		ListNode current = head;
		ListNode lastNodeofSubList = current;
		ListNode next = null;

		while (true) {
			int n = k;
			int m = 1;
			int z = 1;

			while (n - m >= 0 && current != null) {
				next = current.next;
				current.next = prev;
				prev = current;
				current = next;
				--n;
			}
			length = length - k;
			m = z * k + 1;
			n = (++z) * k;

			if (lastNodeofFirstPart == null)
				head = prev;
			else
				lastNodeofFirstPart.next = prev;

			lastNodeofFirstPart = lastNodeofSubList;
			lastNodeofSubList.next = current;
			lastNodeofSubList = current;
			if (current == null)
				break;
			if (length < k)
				break;
		}

		return head;
	}

	int len(ListNode head) {
		int k = 0;
		while (head != null) {
			head = head.next;
			++k;
		}

		return k;
	}
````