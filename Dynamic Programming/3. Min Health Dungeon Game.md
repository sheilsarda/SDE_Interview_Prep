# 3. Min Health Dungeon Game

- The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.
- The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.
- Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).
- To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.
- Return the knight's minimum initial health so that he can rescue the princess.

**Note** any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.

## Examples

````
Example 1:
Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
Output: 7
Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.

Example 2:
Input: dungeon = [[0]]
Output: 1
````

## Code

### DFS Solution

````cpp
class Solution {
    int n, m;
    int dfs(int x, int y, vector<vector<int>>& nums, vector<vector<int>> &dp)
    {
        if(x >= n || x < 0 || y >= m || y < 0)
            return INT_MIN;
        if(x == n-1 && y == m-1) return nums[x][y];
        if(dp[x][y] != -1) return  dp[x][y];
        int ans = nums[x][y];
        int val = nums[x][y]+max(dfs(x+1, y, nums, dp), dfs(x, y+1, nums, dp));
        return dp[x][y] = min(ans, val);
    }
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        n = dungeon.size();
        m = dungeon[0].size();
        vector<vector<int>> dp(n+1, vector<int> (m+1, -1));
        int val = dfs(0, 0, dungeon, dp);
        if(val >= 0)
            return 1;
        else
        {
            val = -1*val;
            return val + 1;
        }
    }
};
````

### Recursive Solution

````cpp
class Solution {

public:

    int dpSolution(int i,int j,vector<vector<int>>& dungeon,vector<vector<int>> &dp){

        if(i>=dp.size()||j>=dp[0].size()) return 5e5;
        
        if(i==dp.size()-1&&j==dp[0].size()-1) {
            if(dungeon[i][j]<=0) return abs(dungeon[i][j])+1;
            else return 1;
        } 
        
        if(dp[i][j]!=-1) return dp[i][j];
        
        int up = dpSolution(i+1,j,dungeon,dp);
        int down = dpSolution(i,j+1,dungeon,dp);
        
        int minhealthreq = min(up,down)-dungeon[i][j];
        
        return dp[i][j] = (minhealthreq<=0)?1:minhealthreq;
    }
    
    int calculateMinimumHP(vector<vector<int>>& dungeon) {

        int m=dungeon.size(),n=dungeon[0].size();

        vector<vector<int>> dp(m,vector<int>(n,-1));
        return dpSolution(0,0,dungeon,dp); 
    }
};
````