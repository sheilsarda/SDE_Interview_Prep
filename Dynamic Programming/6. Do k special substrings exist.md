
# Count number of special substrings

### Attempt 1; doesn't work for `acdbdbca` where there's a valid special substring in the middle

```cpp
#include <unordered_map>

class Solution {
public:
    bool maxSubstringLength(string s, int k) {
        std::unordered_map<char, int> char_count;
        for(int i = 0; i < s.size(); ++i){
            char c = s[i];

            if(i + 1 < s.size() && s[i+1] == c) // Special case where consecutive occurences of the same char should be collapsed to a count of 1
                continue;

            if(char_count.contains(c)){
                char_count[c]++;
            } else char_count[c] = 1;
        }

        int max_special_substr_count = 0;
        for(auto pair : char_count){
            if(pair.second == 1){
                max_special_substr_count++;
            }
        }
        return max_special_substr_count >= k;
    }
};
```

### Greedy solution

```cpp
class Solution
{
public:
    bool maxSubstringLength(std::string s, int k)
    {
        int strLen = s.size();
        if (k == 0)
        {
            return true;
        } 
        
        std::vector<int> firstOccur(26, strLen), lastOccur(26, -1);
        
        // Step 1: Find first and last occurrence of each character
        for (int pos = 0; pos < strLen; pos++)
        {
            int charIdx = s[pos] - 'a';
            firstOccur[charIdx] = std::min(firstOccur[charIdx], pos);
            lastOccur[charIdx] = std::max(lastOccur[charIdx], pos);
        }

        std::vector<std::pair<int, int>> segments;
        
        // Step 2: Find valid segments
        for (int start = 0; start < strLen; start++)
        {
            if (start != firstOccur[s[start] - 'a'])
            {
                continue;
            } 

            int farthest = lastOccur[s[start] - 'a'];
            int current = start;
            bool isValid = true;

            while (current <= farthest)
            {
                if (firstOccur[s[current] - 'a'] < start)
                {
                    isValid = false;
                    break;
                }
                
                farthest = std::max(farthest, lastOccur[s[current] - 'a']);
                current++;
            }

            if (isValid && !(start == 0 && farthest == strLen - 1))
            {
                segments.emplace_back(start, farthest);
            }
        }

        // Step 3: Sort the segments based on ending index
        std::sort(segments.begin(), segments.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b)
        {
            return a.second < b.second;
        });

        // Step 4: Count non-overlapping segments
        int segmentCount = 0, lastIndex = -1;
        for (const auto& bounds : segments)
        {
            if (bounds.first > lastIndex)
            {
                segmentCount++;
                lastIndex = bounds.second;
            }
        }

        return segmentCount >= k;
    }
};
```

### DP solution

```cpp
class Solution {
public:
    int dp[50001][27];


    bool solve(int index,vector<int> &lens, vector<int> &canStart,int k,int n){

        if(k==0)
        return 1;

        if(index>=n){
            return 0;
        }

        if(dp[index][k]!=-1) return dp[index][k];

       bool ans =solve(index+1,lens,canStart,k,n);
        if(canStart[index]==1){
          int len=lens[index];

          ans|= solve(index+len,lens,canStart,k-1,n);
        }

        return dp[index][k]=ans;


    }
    bool maxSubstringLength(string s, int k) {
        
        vector<int> firstOcc(26,-1),lastOcc(26,-1);

        int n=s.size();

        for(int i=0;i<n;i++){
            char ch=s[i];

            if(firstOcc[ch-'a']==-1){
                firstOcc[ch-'a']=i;
            
            }
            lastOcc[ch-'a']=i;
        }

      //  for(int i=0;i<26;i++) cout<<firstOcc[i]<<" "<<lastOcc[i]<<endl;


        vector<int> canStart(n,-1);
        vector<int> lens(n,0);

        for(int i=0;i<n;i++){
            char ch=s[i];

            if(firstOcc[ch-'a']==i){
                int fo=i;

                int lo=lastOcc[ch-'a'];
                int len=0;
                for(int j=fo;j<n && j<=lo;j++){
                  char ch2=s[j];

                  if(firstOcc[ch2-'a']>=fo){
                      len++;
                      lo=max(lo,lastOcc[ch2-'a']);
                  }
                  else{
                    canStart[fo]=0;
                    break;
                  }


                }
                if(canStart[i]==-1) canStart[i]=1;

                lens[fo]=len;
            }
            else{
                canStart[i]=0;
            }
        }

       if(lens[0]==n) canStart[0]=0;
       memset(dp,-1,sizeof(dp));

       return solve(0,lens,canStart,k,n);

       // return 0;
    }
};
```