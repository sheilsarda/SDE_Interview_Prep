# 3302. Find the Lexicographically Smallest Valid Sequence

You are given two strings word1 and word2.

A string x is called almost equal to y if you can change at most one character in x to make it identical to y.

A sequence of indices seq is called valid if:

The indices are sorted in ascending order.
Concatenating the characters at these indices in word1 in the same order results in a string that is almost equal to word2.
Return an array of size word2.length representing the lexicographically smallest valid sequence of indices. If no such sequence of indices exists, return an empty array.

Note that the answer must represent the lexicographically smallest array, not the corresponding string formed by those indices.

### How to set this up as a DP problem

Dynamic Programming Array: We use a DP array dp where dp[i] represents the number of matching characters of s2 starting from index i in s1. The array is initialized with n + 1 elements (where n is the length of s1) to handle the base case easily.

Backward Matching: We iterate through s1 in reverse order to fill the dp array. If characters at the current index of s1 and s2 match, we increment our count of matches and move to the next character in s2. This way, we get a count of how many characters of s2 can still be matched starting from any position in s1.

Finding Valid Indices: We then iterate through s1 again, this time from the start. For each character in s1, we check:

If it matches the current character in s2, we add its index to the result.
If it doesn't match, we check if we can skip this character. If the remaining matches (tracked in the dp array) plus one is greater than the characters left to match in s2, we can skip this character.
Final Validation: If the size of the result indices does not equal the length of s2, we return an empty list, indicating that s2 cannot be formed with the allowed operations.


```cpp
class Solution {
public:
    vector<int> validSequence(string s1, string s2) {
        int n = s1.size();
        int m = s2.size();
        vector<int> ans;
        vector<int> dp(n+1);
        bool changed = 1;
        int curIdx = m-1;
        for(int i=n-1;i>=0;i--){
            dp[i] = dp[i+1];
            if(curIdx >=0 && s1[i] == s2[curIdx]){
                curIdx--;
                dp[i]++;
            }
        }
        int j = 0;
        for(int i=0;i<n && j<m;i++){
            if(s1[i] == s2[j]){
                ans.push_back(i);
                j++;
            }else if(dp[i+1] + 1 > m-j-1 && changed == 1){
                ans.push_back(i);
                changed = 0;
                j++;
            }
        }
        if(ans.size() != m){
            return {};
        }
        return ans;
    }
};
```