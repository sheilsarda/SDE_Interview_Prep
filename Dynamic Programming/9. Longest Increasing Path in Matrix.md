# 329. Longest Increasing Path in a Matrix

Given an m x n integers matrix, return the length of the longest increasing path in matrix.

From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).


Example 1:

Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].

Example 2:

Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

Example 3:

Input: matrix = [[1]]
Output: 1
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
0 <= matrix[i][j] <= 231 - 1

### CPP solution

```
class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int num_rows = matrix.size();
        int num_cols = matrix[0].size();
        
        // dp[i][j] = longest increasing path starting from (i,j)
        vector<vector<int>> dp(num_rows, vector<int>(num_cols, 0));
        
        int maxPath = 1;
        
        // Try starting from every cell
        for(int i = 0; i < num_rows; ++i) {
            for(int j = 0; j < num_cols; ++j) {
                maxPath = max(maxPath, dfs(matrix, dp, i, j));
            }
        }
        
        return maxPath;
    }
    
private:
    vector<pair<int,int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    
    int dfs(vector<vector<int>>& matrix, vector<vector<int>>& dp, int r, int c) {
        // If already computed, return memoized value
        if(dp[r][c] != 0) {
            return dp[r][c];
        }
        
        int maxLen = 1; // At minimum, path of length 1 (just this cell)
        
        // Try all 4 directions
        for(auto& [dr, dc] : dirs) {
            int nr = r + dr;
            int nc = c + dc;
            
            // Check bounds
            if(nr < 0 || nr >= matrix.size() || nc < 0 || nc >= matrix[0].size()) {
                continue;
            }
            
            // Only move to strictly greater values
            if(matrix[nr][nc] > matrix[r][c]) {
                maxLen = max(maxLen, 1 + dfs(matrix, dp, nr, nc));
            }
        }
        
        // Memoize and return
        dp[r][c] = maxLen;
        return maxLen;
    }
};
```

### Alternatively, using BFS

```cpp
class Solution {
public:
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int num_rows = matrix.size();
        int num_cols = matrix[0].size();
        
        // Create list of all cells sorted by value
        vector<pair<int, pair<int,int>>> cells;
        for(int i = 0; i < num_rows; ++i) {
            for(int j = 0; j < num_cols; ++j) {
                cells.push_back({matrix[i][j], {i, j}});
            }
        }
        
        // Sort cells by value (ascending)
        sort(cells.begin(), cells.end());
        
        vector<vector<int>> dp(num_rows, vector<int>(num_cols, 1));
        vector<pair<int,int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
        
        int maxPath = 1;
        
        // Process cells in increasing order of value
        for(auto& [val, pos] : cells) {
            int r = pos.first;
            int c = pos.second;
            
            // Look at all neighbors with smaller values
            for(auto& [dr, dc] : dirs) {
                int nr = r + dr;
                int nc = c + dc;
                
                if(nr >= 0 && nr < num_rows && nc >= 0 && nc < num_cols 
                   && matrix[nr][nc] < matrix[r][c]) {
                    dp[r][c] = max(dp[r][c], dp[nr][nc] + 1);
                }
            }
            
            maxPath = max(maxPath, dp[r][c]);
        }
        
        return maxPath;
    }
};
```