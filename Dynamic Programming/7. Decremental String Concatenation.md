# 2746. Decremental String Concatenation

You are given a 0-indexed array words containing n strings.

Let's define a join operation join(x, y) between two strings x and y as concatenating them into xy. However, if the last character of x is equal to the first character of y, one of them is deleted.

For example join("ab", "ba") = "aba" and join("ab", "cde") = "abcde".

You are to perform n - 1 join operations. Let str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation, you can do one of the following:

Make stri = join(stri - 1, words[i])
Make stri = join(words[i], stri - 1)
Your task is to minimize the length of strn - 1.

Return an integer denoting the minimum possible length of strn - 1.

### Partially correct solution - my attempt; greedy solution

```cpp
#include <string>
#include <iostream>

class Solution {
public:

    int minimizeConcatenatedLength(vector<string>& words) {
        string str_i = words[0];
        // maintain str_i, starting as words[0]

        for(int i = 1; i < words.size(); ++i){

            // pick the join operation based on if we're
            // eliminating X letters by doing it one way or Y doing 
            // it the other way, pick the max of the X and Y

            auto word_to_append = words.at(i);            
            // std::reverse(word_to_append.begin(), word_to_append.end());
            std::cout << "First char of word " << word_to_append << " is " << word_to_append[0] << std::endl;
            if (str_i.back() == word_to_append[0]){
                // std::cout << "we think str_i's end char [" << str_i << "] matches beginning of words[i] [" << words[i] << std::endl;
            
                str_i += words[i].substr(1);
                std::cout << str_i << " prefix; " << words[i] << std::endl;
            } else if (str_i[0] == word_to_append.back()){
                str_i = words[i] + str_i.substr(1);
                std::cout << str_i << " suffix; " << words[i] << std::endl;
            } else {
                // consider the one lookahead case
                if (i + 1 < words.size() && 
                (words[i].back() == words[i+1][0] || str_i[0] == words[i + 1].back())){
                    str_i += words[i];
                    std::cout << "lookahead 1; " << words[i] << std::endl;

                } else {
                    str_i = words[i] + str_i;
                    std::cout << "lookahead 2; " << words[i] << std::endl;
                }
                std::cout << "no efficiency; " << str_i << std::endl;

            }
        }
        std::cout << str_i << std::endl;
        return str_i.size();
    }
};
```

### Correct DP Solution

```cpp
class Solution {
public:
    int minimizeConcatenatedLength(vector<string>& words) {
        int n = words.size();
        int dp[2][26][26];  

        // Set all path to non-reachable state (-1)
        memset(dp, -1, sizeof(dp));

        // Initialize the first reachable state
        int len = words[0].size();
        int total = len;
        int head = words[0][0]-'a';
        int tail = words[0][len-1]-'a';
        dp[0][head][tail] = 0;
        
        int best = 0;        
        for (int i=1; i<n; i++) {
            len = words[i].size();
            total += len;
            head = words[i][0]-'a';
            tail = words[i][len-1]-'a';

            int curr = i & 1;
            int prev = (i + 1) & 1;

            // Clear current dp state
            memset(dp[curr], -1, sizeof(dp[curr]));

            // Check reachable head&tail combination
            for (int h=0; h<26; h++)
            for (int t=0; t<26; t++) {
                // Skip non reachable states
                if (dp[prev][h][t] == -1) continue;
                
                // Prune if no chance to beat best
                // (not enough remaining words to beat the best score)
                if (dp[prev][h][t] + (n - i) <= best) continue;

                // We can use current tail to match previous head, or vice versa
                dp[curr][head][t] = max(dp[curr][head][t], dp[prev][h][t] + (tail == h));
                dp[curr][h][tail] = max(dp[curr][h][tail], dp[prev][h][t] + (head == t));
                best = max({best, dp[curr][head][t], dp[curr][h][tail]});
            }
        }

        // Don't forget what we are here for : 
        // minimum length, not maximum reduction.
        return total - best;
    }
};
```

### Even faster DP solution from Claude

```cpp
class Solution {
public:
    int minimizeConcatenatedLength(vector<string>& words) {
        int n = words.size();
        if (n == 1) return words[0].length();
        
        // dp[first][last] = minimum length with first/last characters
        // Using arrays instead of vectors for better performance
        int dp[26][26];
        int newDp[26][26];
        
        // Initialize with maximum values
        memset(dp, 0x3f, sizeof(dp));
        
        // Start with the first word
        int firstChar = words[0][0] - 'a';
        int lastChar = words[0].back() - 'a';
        dp[firstChar][lastChar] = words[0].length();
        
        // Process each subsequent word
        for (int i = 1; i < n; i++) {
            memset(newDp, 0x3f, sizeof(newDp));
            
            int wordFirst = words[i][0] - 'a';
            int wordLast = words[i].back() - 'a';
            int wordLen = words[i].length();
            
            for (int f = 0; f < 26; f++) {
                for (int l = 0; l < 26; l++) {
                    if (dp[f][l] > 1e9) continue; // Skip invalid states
                    
                    // Option 1: Append words[i] -> join(current, words[i])
                    // New string: starts with f, ends with wordLast
                    int appendLen = dp[f][l] + wordLen;
                    if (l == wordFirst) appendLen--; // Save one character
                    newDp[f][wordLast] = min(newDp[f][wordLast], appendLen);
                    
                    // Option 2: Prepend words[i] -> join(words[i], current)
                    // New string: starts with wordFirst, ends with l
                    int prependLen = dp[f][l] + wordLen;
                    if (wordLast == f) prependLen--; // Save one character
                    newDp[wordFirst][l] = min(newDp[wordFirst][l], prependLen);
                }
            }
            
            memcpy(dp, newDp, sizeof(dp));
        }
        
        // Find the minimum length across all possible configurations
        int result = INT_MAX;
        for (int f = 0; f < 26; f++) {
            for (int l = 0; l < 26; l++) {
                result = min(result, dp[f][l]);
            }
        }
        
        return result;
    }
};
```