# Maximum Weighted K-Edge Path

You are given an integer n and a Directed Acyclic Graph (DAG) with n nodes labeled from 0 to n - 1. This is represented by a 2D array edges, where edges[i] = [ui, vi, wi] indicates a directed edge from node ui to vi with weight wi.

You are also given two integers, k and t.

Your task is to determine the maximum possible sum of edge weights for any path in the graph such that:

The path contains exactly k edges.
The total sum of edge weights in the path is strictly less than t.
Return the maximum possible sum of weights for such a path. If no such path exists, return -1.

```rust
use std::collections::{HashMap, HashSet};

impl Solution {
    pub fn max_weight(n: i32, edges: Vec<Vec<i32>>, k: i32, t: i32) -> i32 {
        // Build adjacency list
        let mut graph: Vec<Vec<(i32, i32)>> = vec![Vec::new(); n as usize];
        for edge in &edges {
            let (u, v, w) = (edge[0], edge[1], edge[2]);
            graph[u as usize].push((v, w));
        }
        
        // Use HashSet to automatically deduplicate sums
        let mut dp: Vec<HashMap<i32, HashSet<i32>>> = vec![HashMap::new(); (k + 1) as usize];
        
        // Base case: can start at any node with sum 0
        for i in 0..n {
            dp[0].entry(i).or_insert_with(HashSet::new).insert(0);
        }
        
        // Build paths with 1 to k edges
        for num_edges in 1..=k as usize {
            let mut next_dp: HashMap<i32, HashSet<i32>> = HashMap::new();
            
            for node in 0..n {
                if let Some(sums) = dp[num_edges - 1].get(&node) {
                    for &current_sum in sums {
                        for &(neighbor, weight) in &graph[node as usize] {
                            let new_sum = current_sum + weight;
                            
                            // Prune: skip if already >= t (can't be valid answer)
                            if new_sum >= t {
                                continue;
                            }
                            
                            next_dp
                                .entry(neighbor)
                                .or_insert_with(HashSet::new)
                                .insert(new_sum);
                        }
                    }
                }
            }
            
            dp[num_edges] = next_dp;
        }
        
        // Find maximum sum < t with exactly k edges
        let mut result = -1;
        for sums in dp[k as usize].values() {
            for &sum in sums {
                result = result.max(sum);
            }
        }
        
        result
    }
}
```